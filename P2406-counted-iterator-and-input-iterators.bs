<pre class='metadata'>
Title: Fix `counted_iterator` interaction with input iterators
Status: D
Audience: SG9 (Ranges)
Editor: Yehezkel Bernat, YehezkelShB@gmail.com
Editor: Yehuda Bernat, YehudaMBer@gmail.com
Shortname: P2406
Abstract: `counted_iterator` increments its internal iterator even when reaching its own end, which makes it unusable in some cases, especially for input iterators. This paper suggest some changes to improve the situation
Group: WG21
Date: 2021-07-25
Markup Shorthands: markdown yes
Revision: 1
Default Highlight: CPP
ED: https://yehezkelshb.github.io/cpp_proposals/P2406-counted-iterator-and-input-iterators.html
!Source: <a href="https://github.com/YehezkelShB/cpp_proposals/blob/master/P2406-counted-iterator-and-input-iterators.bs">GitHub</a>
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

<pre class="biblio">
{
    "EULER": {
        "href": "https://projecteuler.net/problem=37",
        "title": "Truncatable primes, problem 37, Project Euler"
    },
    "CE-FILTER": {
        "href": "https://gcc.godbolt.org/z/9TjbdMn3d",
        "title": "filter+take problem example, Compiler Explorer"
    },
    "CE-ISTREAM": {
        "href": "https://gcc.godbolt.org/z/Eb8rdWYbP",
        "title": "istream problem example, Compiler Explorer"
    },
    "CE-ISTREAMBUF": {
        "href": "https://gcc.godbolt.org/z/ofeY74xoc",
        "title": "istreambuf behavior example, Compiler Explorer"
    },
    "CE-OPT": {
        "href": "https://gcc.godbolt.org/z/4dahzG8Gz",
        "title": "Optimizer magic solves filter+take issue, Compiler Explorer"
    },
    "CE-OPT2": {
        "href": "https://gcc.godbolt.org/z/PvMY8WeaT",
        "title": "Optimizer is right when filter really never returns, Compiler Explorer"
    },
    "P2578": {
        "href": "https://wg21.link/p2578",
        "title": "Block eager input (non-forward) iterators from counted_iterator"
    }
}
</pre>


Revision History
================

r1: Improving many parts, following feedback from Inbal Levi and from Reddit
users

r0: initial revision


Intro
=====
Project Euler is a project with many mathematical-related questions that are
intended to encourage the reader to write a small program to compute the result.
In this case, one of the problems there, no. 37 [[EULER]], helped reveal a
pitfall coming from the definition of `std::counted_iterator`.


Problem description
===================

Range with the exact number of items
------------------------------------

Look at this example code [[CE-FILTER]]:
```
#include <ranges>
#include <iostream>
 
namespace rv = std::views;
 
int main() {
    for (auto i  : rv::iota(0)
            | rv::filter([](auto i) { return i < 11; })
            | rv::take(11))
        std::cout << i << '\n';
}
```

Compiler explorer gets a timeout when trying to run this simple example, instead
of printing the numbers from 0 to 10. Running the same code locally, it runs for
very long time. Tracking the roots of the issue, the problem is that `take` uses
`counted_iterator` when the range isn't `random_access` and `counted_iterator`
increments the internal iterator even if the counter has reached the requested
count. In this case, the filter never returns when trying to increment it once
again (at least not until `iota` reaches the UB case of signed overflow).

The example above is just for illustration, but we can think about cases where
it isn't clear for the user how many items the filter is expected to return, so
limiting the output count with `take` becomes dangerous and results in
unexpected behavior.

The problem mentioned in the intro is one that actually describes a filter that
return exactly 11 elements, so trying to use `take(11)` on it means the program
never ends even while it got 11 elements already.

It means `take` isn't usable on ranges that have the exact count of items (and
so is `counted_iterator` when wrapping around an iterator for such a range).


`input_iterator` case
---------------------
Even more common problem is when using input ranges, e.g. `basic_istream_view`.
In these cases, advancing the internal iterator when reaching the count means
eating an additional input that can't be retrieved again later, or hanging
forever if no additional input exists and the stream isn't closed.
For example [[CE-ISTREAM]]:

```
#include <ranges>
#include <iostream>
#include <sstream>
#include <cassert>
 
namespace rn = std::ranges;
namespace rv = rn::views;
 
int main()
{
    auto iss = std::istringstream("0 1 2");
    for (auto i : rn::istream_view<int>(iss)
                  | rv::take(1))
        std::cout << i << '\n';
    auto i = 0;
    iss >> i;
    std::cout << i << std::endl; // flush it in case the assert fails
    assert(i == 1); // FAILS, i == 2
}
```

It means that one can't use ranges when parsing input, for example.


Current behavior is what the standard mandates
==============================================

Under 23.5.6.5 [counted.iter.nav], the standard defines the behavior of
`operator++` for `counted_iteraor` as:

Effects: Equivalent to:<br/>
`++current;`<br/>
`--length;`<br/>
`return *this;`<br/>

It means that even when `length` becomes 0, the internal iterator is
incremented, thus consuming an additional item from the range, and causing the
effects mentioned above for input iterator case or when `++` on the internal
iterator is costly (or never returns).


Desired behavior
================

As long as `counted_iterator` is valid (not equal to `default_sentinel`), it
must never try to access more than `n` items (when `n` is the given count). If
the range doesn't have `n` items, the behavior is kept as is, i.e. it isn't
defined (`operator++` might hang forever or access things that shouldn't be
accessed etc.).


Naive design of the solution
============================

Basically, what is required to implement the desired behavior is changing the
behavior of `counted_iterator` operators around 0 length so it doesn't increment
the internal iterator when reaching 0 length.


Designs that were considered (and rejected)
===========================================

Don't increment the internal iterator until really required
-----------------------------------------------------------

This can't work as copying `counted_iterator` of non-forward iterator (that wasn't
dereferenced yet for the current item) and then dereferencing one of them
resulted with invalidation of the other one.

Fix `counted_iterator`
----------------------

Instead of introducing new type, `lazy_counted_iterator`, we tried to apply
similar changes to `counted_iterator` itself. This proved to be impossible, even
if the changes can be done in ABI compatible way. For example, there is no sane
way to fix the c-tor that takes iterator and count, when the count is 0.

`counted_iterator` allows constructing with `0` as argument for length.
If we change `counted_iterator` operators to behave similarly to what we
propose for `lazy_counted_iterator`, this constructor puts the iterator in an
inconsistent internal state, as the next operations will be `base()` or `--`,
and those expect the iterator to be "one step back".

Please note that `base()` and `--` are the only operations involving the state
of the internal iterator and still legal for `counted_iterator` constructed with
`n==0`.

The options we considered and rejected are:

Option 1: Require that if `n==0`, `i` must be decrementable, and actually
decrement it in the c-tor. (This option assumes the only reason to create such
an `counted_iteraor` is to decrement it anyway.)
Please note that this obviously works only for `bidirectional_­iterator`. Other
kind of iterators can be left as UB, or just advice against calling `base()` on
the resulted `counted_iteraor`. This makes existing valid code invalid, e.g. if
the next operation would be to test for the value of `n` before doing anything
else and do nothing in the `0` case.

Option 2: Require that if `n==0`, `i` must be "the one before" the actual
iterator (leaving it to the user to decide how to handle, and if neither `--`
nor `base()` are ever called on it, it doesn't matter what the user does).
This option changes behavior of existing code.

Option 3: Mark this case internally (e.g. with `length=-1` or a boolean flag)
and handle specially when decrementing (`length` "jumps" to `1` after
decrementing the internal iterator). Please note that both the counter/flag and
the internal iterator must be mutable (to be changed on first access to
`base()`). Also, if -1 is used, instead of a separated flag, comparison
operators have to consider this case too. Using a flag, OTOH, will probably push
for separated specialization of the whole class, so for random-access iterators
this member will not exist. This still doesn't solve the problem of invalidation
of one copy when `base()` is called on the other one. It also breaks ABI.


Fundamental problem with `istreambuf_iterator`
==============================================

`istreambuf_iterator` behaves differently than `istream_iterator`. While the
latter removes the element from the underlying source on `++`, the former
removes it only on the next `++` (the read on dereference done directly from the
underlying `streambuf`). It means that `counted_iterator` works flawlessly with
`istreambuf_iterator`.

For example, we can adapt the previous example to use `istreambuf_iterator` and
get the expected behavior [[CE-ISTREAMBUF]]:

```
    auto iss = std::istringstream("012");
    auto ibuf_it = std::istreambuf_iterator<char>(iss);
    for (auto c : rn::subrange(ibuf_it, std::default_sentinel)
                  | rv::take(1))
    {
        std::cout << c << '\n';
    }
    auto c = '\0';
    iss >> c;
    std::cout << c << std::endl; // flush it in case the assert fails
    assert(c == '1'); // SUCCEEDS
```

The conclusion is that we have to differentiate between "eager" and "lazy"
types. See [[P2578]], which introduces `lazy_weakly_incrementable` concept.


Design of suggested solution
============================

The main changes
----------------
We propose adding a new iterator type, `lazy_counted_iterator`. This type
behaves similarly to `counted_iterator`, with changes to its operator definition
around 0 length so it doesn't increment the internal iterator when reaching 0
length, and as a result doesn't decrement it when getting back from 0 to 1
length. This requires changing `base()` behavior too, including the return type
to be by value.

Additionally, this requires adding `lazy_take` and `views::lazy_counted` that
uses the new iterator instead of `counted_iterator`.


`random_access_iterator` case kept as-is
----------------------------------------

To reduce the amount of changes required, we keep the current behavior for
`random_access_iterator` case, so we don't have to touch the additional
operators defined only for this category. The rational behind it is that for
`random_access_iterator` case we can expect the view to either have all the
items ready or able to compute all of them efficiently, so it doesn't suffer
from this issue.


Proposed Wording
================

Note: the current wording is against `counted_iterator` but will be changed
to refer to `lazy_counted_iterator`


Under 23.5.6.3 [**counted.iter.access**]:

<ins>
`constexpr I base() const &;`<br/>
Effects: Equivalent to: `return length ? current : next(current);`<br/>
Note: calling `base()` twice isn't safe when `I` isn't `forward_iterator`
</ins>

`constexpr const I& base() const &;`<br/>
<span class="ins">`  requires random_­access_­iterator<I>;`</span><br/>
Effects: Equivalent to: `return current;`

<ins>
`constexpr I base() &&;`<br/>
Returns: `std​::​move(length ? current : next(current))`.
</ins>

`constexpr I base() &&;`<br/>
<span class="ins">`  requires random_­access_­iterator<I>;`</span><br/>
Returns: `std​::​move(current)`.


Under 23.5.6.5 [**counted.iter.nav**]:

<ins>
`constexpr lazy_counted_iterator& operator++();`<br/>
Preconditions: `length > 0`.<br/>
Effects: Equivalent to:<br/>
`if (length > 1) ++current;`<br/>
`--length;`<br/>
`return *this;`<br/>
</ins>

`constexpr lazy_counted_iterator& operator++();`<br/>
<span class="ins">`  requires random_­access_­iterator<I>;`</span><br/>
Preconditions: `length > 0`.<br/>
Effects: Equivalent to:<br/>
`++current;`<br/>
`--length;`<br/>
`return *this;`<br/>

`decltype(auto) operator++(int);`<br/>
Preconditions: `length > 0`.<br/
Effects: Equivalent to:<br/>
`--length;`<br/>
<span class="del">`try { return current++; }`</span><br/>
<span class="ins">`try { return length ? current++ : current; }`</span><br/>
`catch(...) { ++length; throw; }`<br/>

`constexpr lazy_counted_iterator operator++(int)`<br/>
`  requires forward_­iterator<I>;`<br/>
Effects: Equivalent to:<br/>
`lazy_counted_iterator tmp = *this;`<br/>
`++*this;`<br/>
`return tmp;`<br/>

<ins>
`constexpr lazy_counted_iterator& operator--()`<br/>
`    requires bidirectional_­iterator<I>;`<br/>
Effects: Equivalent to:<br/>
`if (length) --current;`<br/>
`++length;`<br/>
`return *this;`<br/>
</ins>

`constexpr lazy_counted_iterator& operator--()`<br/>
<span class="ins">`  requires random_­access_­iterator<I>;`</span><br/>
Effects: Equivalent to:<br/>
`--current;`<br/>
`++length;`<br/>
`return *this;`<br/>


Appendix
========
It's interesting to note that with any level of optimization enabled (including
`-Og`!), gcc is able to "fix the issue" [[CE-OPT]] for the filter+take case (but
not for `input_iterator`, of course). It's maybe even more interesting to see
the mentioned optimization is not an optimizer bug, and when the filter will
never return another number, it doesn't change the behavior [[CE-OPT2]].
