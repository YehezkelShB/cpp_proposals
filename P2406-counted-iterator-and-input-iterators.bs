<pre class='metadata'>
Title: Add `lazy_counted_iterator`
Status: D
Audience: SG9 (Ranges)
Editor: Yehezkel Bernat, YehezkelShB@gmail.com
Editor: Yehuda Bernat, YehudaMBer@gmail.com
Shortname: P2406
Abstract: `counted_iterator` increments its internal iterator even when reaching its own end, which makes it unusable in some cases, especially for input iterators. This paper suggests adding `lazy_counted_iterator` alternative to be used in such cases
Group: WG21
Date: 2023-01-02
Markup Shorthands: markdown yes
Revision: 2
Default Highlight: CPP
ED: https://wg21.link/P2406
!Source: <a href="https://github.com/YehezkelShB/cpp_proposals/blob/master/P2406-counted-iterator-and-input-iterators.bs">GitHub</a>
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

<pre class="biblio">
{
    "CE-FILTER": {
        "href": "https://gcc.godbolt.org/z/9TjbdMn3d",
        "title": "filter+take problem example, Compiler Explorer"
    },
    "CE-ISTREAM": {
        "href": "https://gcc.godbolt.org/z/Eb8rdWYbP",
        "title": "istream problem example, Compiler Explorer"
    },
    "CE-OPT": {
        "href": "https://gcc.godbolt.org/z/4dahzG8Gz",
        "title": "Optimizer magic solves filter+take issue, Compiler Explorer"
    },
    "CE-OPT2": {
        "href": "https://gcc.godbolt.org/z/PvMY8WeaT",
        "title": "Optimizer is right when filter really never returns, Compiler Explorer"
    },
    "LWG3391": {
        "href": "https://cplusplus.github.io/LWG/issue3391",
        "title": "LWG3391 - Problems with counted_iterator/move_iterator::base() const &"
    },
    "range-v3-issue57": {
        "href": "https://github.com/ericniebler/range-v3/issues/57",
        "title": "range-v3 - istream_range filtered with take(N) should stop reading at N"
    },
    "reddit-cpp": {
        "href": "https://www.reddit.com/r/cpp/comments/orw4q8/wg21_july_2021_mailing/h6kqu7y",
        "title": "r/cpp comments on P2406R0"
    },
    "P2406R0": {
        "href": "https://wg21.link/p2406r0",
        "title": "P2406R0"
    },
    "D2406R1": {
        "href": "https://isocpp.org/files/papers/D2406R1.html",
        "title": "D2406R1"
    }
}
</pre>

# Revision History

r2: Integrating SG9 feedback:
- Removing references to p2578, after SG9 vote against it
- Fix design suggested
- Add design alternatives

r1: Improving many parts, following feedback from Inbal Levi and from Reddit
users - [[D2406R1]]

r0: initial revision - [[P2406R0]]


# Problem description

## Range with the exact number of items

Look at this example code [[CE-FILTER]]:
```
#include <ranges>
#include <iostream>
 
namespace rv = std::views;
 
int main() {
    for (auto i  : rv::iota(0)
            | rv::filter([](auto i) { return i < 11; })
            | rv::take(11))
        std::cout << i << '\n';
}
```

Compiler explorer gets a timeout when trying to run this simple example, instead
of printing the numbers from 0 to 10. Running the same code locally, it runs for
very long time. Tracking the roots of the issue, the problem is that `take` uses
`counted_iterator` when the range isn't `random_access` and `counted_iterator`
increments the internal iterator even if the counter has reached the requested
count. In this case, the filter never returns when trying to increment it once
again (at least not until `iota` reaches the UB case of signed overflow).

The example above is just for illustration, but we can think about cases where
it isn't clear for the user how many items the filter is expected to return, so
limiting the output count with `take` becomes dangerous and results in
unexpected behavior.

It means `take` isn't usable on ranges if we don't know in advance that there is
an extra element in the range.


## `input_iterator` case

Even more common problem is when using input ranges, e.g. `basic_istream_view`.
In most of these cases, advancing the internal iterator when reaching the count
means eating an additional input that can't be retrieved again later, or hanging
forever if no additional input exists and the stream isn't closed. For example
[[CE-ISTREAM]]:

```
#include <ranges>
#include <iostream>
#include <sstream>
#include <cassert>
 
namespace rn = std::ranges;
namespace rv = rn::views;
 
int main()
{
    auto iss = std::istringstream("0 1 2");
    for (auto i : rn::istream_view<int>(iss)
                  | rv::take(1))
        std::cout << i << '\n';
    auto i = 0;
    iss >> i;
    std::cout << i << std::endl; // flush it in case the assert fails
    assert(i == 1); // FAILS, i == 2
}
```

It makes it harder to use ranges for things like parsing input, if the rest of
the stream is still to be used or we aren't sure there is any additional element
in the stream.

Seems like this was discussed in [[range-v3-issue57]], and there was no decision
what is the right solution.


# Current behavior is what the standard mandates

Under 23.5.6.5 [counted.iter.nav], the standard defines the behavior of
`operator++` for `counted_iterator` as:

Effects: Equivalent to:<br/>
`++current;`<br/>
`--length;`<br/>
`return *this;`<br/>

It means that even when `length` becomes 0, the internal iterator is
incremented, thus consuming an additional item from the range, and causing the
effects mentioned above for input iterator case or when `++` on the internal
iterator is costly (or never returns).


# Desired behavior

As long as `counted_iterator` is valid (not equal to `default_sentinel`), it
must never try to access more than `n` items (when `n` is the given count). If
the range doesn't have `n` items, the behavior is kept as is, i.e. it isn't
defined (`operator++` might hang forever or access things that shouldn't be
accessed etc.).


# High-level design of the proposed solution

We propose adding a new iterator type, `lazy_counted_iterator`. This type
behaves similarly to `counted_iterator`, with changes to its operator definition
around 0 count so it doesn't increment the internal iterator when reaching 0
count.

Additionally, this requires adding `lazy_take` and `views::lazy_counted` that
uses the new iterator instead of `counted_iterator`.

See below ([[#design-alternatives]]) for more details.


# Design points for discussion

## `random_access_iterator` case

To reduce the amount of changes required, we kept the current behavior for
`random_access_iterator` case, so we don't have to touch the additional
operators defined only for this category. The rational behind it is that for
`random_access_iterator` case we can expect the view to either have all the
items ready or able to compute all of them efficiently, so it doesn't suffer
from an issue similar to the one `forward_iterator` might have.


## Consructing with 0 count

Similarly to `counted_iterator`, `lazy_counted_iterator` must allow constructing
with 0 count. In most design alternatives, this puts the iterator in an
inconsistent internal state, as the underlying iterator is expected to be "one
step back".

Please note that `base()` and decrementing are the only operations involving the
state of the internal iterator and still legal for `counted_iterator`
constructed with `n==0`.

The options we see:

Option 1: Require that if `n == 0`, `i` must be decrementable, and actually
decrement it in the c-tor. Please note that this obviously works only for
`bidirectional_Â­iterator`. Other kind of iterators can be left as UB, or just
advice against calling `base()` on the resulted `counted_iterator` (which
doesn't sound correct, blocking a basic operation like `base()`).

This option assumes the only reason to create such an `counted_iterator` is to
decrement it later, so we always expect the given iterator to be decrementable.
Obviously, we can't really assume it. The next operation could be to test for
`count()` before doing anything else and do nothing in the `0` case. This
happens naturally in a pipeline if the passed range becomes empty, for example.

Option 2: Require that if `n==0`, `i` must be "the one before" the actual
iterator (leaving it to the user to decide how to handle, and if neither `--`
nor `base()` are ever called on it, it doesn't matter what the user does). This
option changes behavior of existing code so it's isn't relevant either.

Option 3: Mark this case internally (e.g. with `length=-1` or a boolean flag)
and handle specially when decrementing (`length` "jumps" to `1` after
decrementing the internal iterator). Implementation must be careful if -1 is
used, instead of a separated flag, as comparison operators have to consider this
case too. Using a flag, OTOH, will probably push for separated specialization of
the whole class, so for random-access iterators this member will not exist.


## `base()`

When reaching 0 count, if `base()` still simply returns the underlying iterator,
it returns the "one before" iterator in most cases.

If we want it to return the actual end (as users expect) and make the behavior
consistent, it means we must advance the underlying iterator first. This doesn't
allow `base()` to be `const` (at least logically) and invalidates other copies
of the iterator (in case of non-forward iterator). As this option seems the most
reasonable one, we based out [[#alternatives-for-base]] suggestions on it.

Another option is to return by value, so this increment only a copy of the
underlying operator and keeps `base()` as `const` member. Besides having the
invlidation problem here (maybe worse than before, as it invalidated the current
object too, so calling `base()` twich isn't allowed!), this prevents using it
with move-only iterators, as mentioned in [[LWG3391]].


## Why `lazy_take` instead of fixing `take`?

We could have change `take` to use `lazy_counted_iterator` when constructed with
input (non lazy) range. Besides ABI considerations, we find it wrong if `take`
used to return one type (`counted_iterator`) and now will start returning a
different one, `lazy_counted_iterator`, as this is source-breaking change.
Additionally, as demonstrated above, there are cases where the user wants using
`lazy_counted_iterator` on forward iterators too, but this is something that
only the user know and we can't automatically detect and decide on behalf of
them. We can't change all cases of `take` to use `lazy_counted_iterator`, due to
the differences in behavior both for lazy input iterators and forward iterators
(that are not random access), as described below.

We aren't happy with the additional burden on teachability, but we believe in
most cases users can just use `lazy_take` and it does The Right Thing. The only
point where users must be aware of it is when they use `base()` method, which we
expect to be quite advance usage in general. Users who care about absolute
performance, can choose using `take` when they know it works correctly for their
case.


### Improve discoverability and teachability

An option mentioned in the discussions was to improve discoverability by
renaming `counted_iterator` and `take` to `eager_counted_iterator` and
`eager_take` and calling the new tools `counted_iterator` and `take`.

Another variation was to call the new tools `lazy_counted_iterator` and
`lazy_take` as suggested here, rename the existing one to have `eager_` prefix
and add new versions of `counted_iterator` and `take` that alias the `lazy_`
version for `input_iterator` case and keep aliasing the `eager_` version for
the rest of the cases.

While leaving the user the option to choose the option that fits their specific
use-case, it still provides a safer default.

We believe this option is problematic as it might be source breaking (e.g.
`counted_iterator ci = take(i, 4).begin();` for the second variation, or any
usage of interface that isn't provided by the new tools in any variation), but
still wanted to mention this option for discussion.


# Design alternatives

Following are the design alternatives we came up with, after the discussions
happend over the previous revisions:


## Option 1 - As closer to `counted_iterator` as possible

With this option, `lazy_counted_iterator` is almost identical to
`counted_iterator` with the following changes:
1. For `random_access_iterator`, the behavior is the same. <br />
   Reason: If an iterator is random access, we expect it to know when we reach
   the end. (Question: maybe we actually want `sized_iterator` here?)
1. Incrementing `lazy_counted_iterator` doesn't increment the underlying
   iterator when reaching 0 count.
1. Decrementing `lazy_counted_iterator` doesn't decrement the underlying
   iterator when current count is 0.
1. Implementation must handle correctly `lazy_counted_iterator` constructed with
   0 count (e.g. marking it differently so it knows to decrement the underlying
   iterator despite the previous point).


## Option 2 - Capped to `forward_iterator`

With this option, `lazy_counted_iterator` provides `forward_iterator` interface
(at max). This removes the need to handle decrementing correctly. (Implementations
might still choose to track the case of `lazy_counted_iterator` constructed with 0
count for validating the precondition of iterator comparison.)


## Option 3 - Don't read it if created with 0 count

This option is similar to option 1, but to simplify the handling of an iterator
constructed with 0 count, disallows using such an iterator with any operation
that access the underlying iterator (no `--` or `base()`) or comparing to
another iterator (effectively allowing only calling `count()` and comparing to
sentinel). Please note that if we choose option III below, it means that after
calling `base()`, same restrictions apply on that iterator, including diallowing
another call to `base()`.


## Option 4 - Don't increment the underlying iterator until really required

Increment the underlying iterator only on first dereference. This makes
dereferencing a non-`const` operation. Additionally, copying
`lazy_counted_iterator` of non-forward iterator (that wasn't dereferenced yet
for the current item) and then dereferencing one of them resulted with
invalidation of the other one. To improve the situation we can make
`lazy_counted_iterator` non-copyable.


## Alternatives for `base()`

### Option I - Don't provide `base()`

In this option, we just don't provide `base()`. Returning the underlying
iterator when count is 0 can be confusing (it depends if `lazy_counted_iterator`
was created with 0 count or reached this state by incrementing it) or invoking
the same issue we try to solve here (if we increment the iterator here).
Additionally, if we increment the underlying iterator on first access to
`base()`, it can't be `const` (at least not logically), it invalidates other
copies of the iterator in case of `input_iterator` and (even if we go with
option 2 above) adds back the complexity of tracking if the iterator was
incremented already (e.g. constructed with 0 count).

If we go with option 1 above, it means that for `random_access_iterator` we keep
providing `base()`, like `counted_iterator` does, as there is no reason not to.

Wording must be adjustment when other functionality is defined in terms of
calling `base()` and implementation can access the underlying iterator directly
when needed.


### Option II - Make `lazy_counted_iterator` non-copyable

Provide `base()` function which increments the underlying iterator if needed.
Users are warned that calling `base()` means non-lazy behavior. Implementation
must not invoke it if not explicitly requested (same wording adjustment is
required as in the previous option). We make `lazy_counted_iterator`
non-copyable even if the underlying iterator is copyable. If it's non-copyable,
we don't have to worry about invalidation (at least not directly; it still
invalidates copies of the underlying iterator).


### Option III - Provide `base()` and mention it invalidates other copies

Provide `base()` and specify it as invalidating other copies, leaving it to the
users to use it correctly. Implementation must increment the underlying iterator
if needed (reached 0 count and this is the first time `base()` is called).


# Note about optimization

It's interesting to note that with any level of optimization enabled (including
`-Og`!), gcc is able to "fix the issue" [[CE-OPT]] for the filter+take case (but
not for `input_iterator`, of course). It's maybe even more interesting to see
the mentioned optimization is not an optimizer bug, and when the filter will
never return another number, it doesn't change the behavior [[CE-OPT2]].


# Acknowledgements

Many thanks to the Israeli NB members for their feedback and support, in
particular Inbal Levi, Dvir Yitzchaki, Dan Raviv and Andrei Zissu. Thanks r/cpp
Reddit users for their feedback on P2406R0 [[reddit-cpp]]. Thanks SG9 members
for their feedback and guidance.
